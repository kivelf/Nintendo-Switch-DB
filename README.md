# Nintendo-Switch-DB
## A personal project created with the goal of refreshing and improving my SQL skills

![Nintendo Switch database](https://github.com/user-attachments/assets/13300165-0c7a-4786-9ac7-c01d84f3e512)

# Motivation
As an essential skill in data management and analysis, SQL is foundational for many modern applications, making it important for anyone interested in working in data-centric fields. As I wanted to refresh and expand the knowledge I gained through lectures, I created this project to deepen my understanding of the language. This not only allowed me to reinforce my database management skills, but also provided an opportunity to integrate Python for automating data generation.
To make the project more engaging, I chose to focus on a subject that I am passionate about — video games — thereby combining my technical learning with personal interests. This approach has made the project both educational and fun, offering a comprehensive experience in database creation and manipulation.

# Goals for the project
The primary goals of this project were centered around honing my database design and SQL skills. I aimed to practise designing a well-structured database with multiple tables while ensuring proper normalisation to eliminate redundancy and optimise performance. In addition to refreshing my existing SQL knowledge, I aimed at deepening my understanding by using more advanced features, such as creating views, stored procedures and triggers. I also wanted to practise implementing safeguards against SQL injection. Another key objective was to practise writing more complex queries and retrieving data from a relatively large dataset, which consists of around 5,000 entries in total.

# Execution
I started by designing the database schema using **Visual Paradigm** to create an Entity-Relationship Diagram (ERD) that clearly mapped out the relationships between the different entities. The database consists of five key tables: `Publisher`, `Developer`, `Game`, `Player`, and `Plays`. These tables were designed to represent real-world relationships in the video game ecosystem, allowing us to explore how players interact with games, developers, and publishers.

![Screenshot 2024-09-08 at 13-55-51 DB Project documentation - Google Docs](https://github.com/user-attachments/assets/1c1ef93d-3a77-4bf0-8a86-4dc3b0e8bdc8)

*Diagram created in Visual Paradigm*

The database schema was implemented using **MS SQL Server**, where I wrote SQL scripts to create the tables, populate them with data, and establish relationships through foreign keys. Special care was taken to ensure proper normalisation to at least the **Third Normal Form (3NF)** in order to avoid redundancy and ensure data consistency. The process of normalisation helped eliminate repeating groups and ensure that functional dependencies were maintained.

![Screenshot 2024-09-08 at 13-57-21 DB Project documentation - Google Docs](https://github.com/user-attachments/assets/e2c5e551-293d-47c0-8f5a-4c5fae95fc6d)

*The database diagram from MS SQL Server looks identical to the Visual Paradigm diagram*

In terms of data population, I manually added around 100 entries across the `Publisher`, `Developer` and `Game` tables, while the `Player` and `Plays` tables were populated with about 5000 records generated by Python scripts.

![Screenshot 2024-09-08 at 13-58-23 DB Project documentation - Google Docs](https://github.com/user-attachments/assets/458d55e9-e12c-4bba-ab5f-36dcba8e5e57)

*The DB structure in MS SQL Server*

To streamline recurring tasks and queries, I wrote several **stored procedures** and **views**. For example I created a stored procedure, `AddNewGame`, to allow the easy insertion of new game data. Additionally, the stored procedure `SearchPlayerByUsername` was designed with SQL injection prevention in mind, using **parameterized queries** to safeguard against malicious inputs. This is a critical aspect of database security as it prevents attackers from manipulating queries to access or corrupt data.

Beyond stored procedures I created **views** for commonly accessed data, such as `TopSellingGames`, which categorises games based on sales, and `PlayerFavourites`, which lists players and their favourite games. These views simplified data retrieval, making it easier to gain insights without writing complex queries repeatedly.

In addition to views and procedures I implemented **triggers** to automate database behaviours. One such trigger, `PreventHighSalesGameDeletion`, prevents the deletion of a game with more than 10 million sales, maintaining data consistency and protecting important records. Another trigger, `UpdateDeveloperCountry`, automatically updates a developer’s country based on the release date of a game they worked on. This trigger uses conditional logic to categorise developers as "Unknown," "Global," or "Modern," depending on the game's release period.

These features, combined with traditional SQL queries, enhanced both the functionality and security of the database. Complex queries involving joins, aggregation, and filtering were used to derive insights about player behaviour, game popularity and developer output.

# Notes and Improvement Suggestions
Throughout the project I identified several areas for improvement. One key suggestion is further normalising the database by creating a separate `Country` table and referencing it in both the `Publisher` and `Player` tables through foreign keys. This change would **reduce redundancy and improve consistency** by having a single source of truth for country data.

Additional improvement could include expanding the dataset with more real-world records to make the analysis even more representative. Moreover, incorporating **additional triggers** and **constraints** could automate more aspects of data integrity such as validating email formats or automatically updating related records in case of changes.

Lastly, while I have implemented SQL injection protection in one of the stored procedures, extending this security measure across all user-facing procedures is crucial to further harden the database against potential attacks.

# Conclusion
This project allowed me to strengthen my SQL skills and apply advanced database management techniques. Through the creation of a comprehensive schema, the use of stored procedures, views, and triggers, and the focus on security (e.g., SQL injection prevention), I was able to design a robust and functional database system.

The project highlighted the importance of careful schema design, proper normalisation and the value of automation via triggers and stored procedures. Looking ahead, this project can be expanded with real-world data and additional safeguards, providing deeper insights and offering more sophisticated use cases in the context of video games and player interactions. Moreover, the database could be used for data analysis and data visualisations (e.g. in Jupyter Notebook).
